# 4X Game

## Introduction

Groups are required to implement, in Unity, the initial stages of a [4X game][4X], specifically a map with different types of terrain and resources. Projects must be developed by **groups of 2 to 3 students**.

## Functionalities

### Summary

The application must (1) open a file describing the game map, (2) display the map on the screen, and (3) allow the user to click on each _tile_ of the map, showing information about that same _tile_.

### Details

#### Maps

Maps are made up of 2D _tiles_. Each _tile_ is composed of **one base terrain type** and **zero or more resources**, which define the **wealth generated by the _tile_** in each turn of the hypothetical 4X game.

A _tile_ can generate two types of wealth, depending on its base terrain type and available resources:

* _Gold_: represents monetary wealth.
* _Food_: represents food production.

A _tile_ has one and only one base terrain type. The following table shows the different base terrain types and the wealth generated by each:

| Base Terrain | File Code | _Gold_ | _Food_ |
|--------------|-----------|-------:|-------:|
| Desert | `desert` | 0 | 0 |
| Grassland | `grassland` | 0 | 2 |
| Hills | `hills` | 1 | 1 |
| Mountain | `mountain` | 1 | 0 |
| Ocean | `ocean` | 0 | 1 |

A _tile_ can also have zero or more resources, which modify the wealth of the base terrain type:

| Resource | File Code | _Gold_ | _Food_ |
|----------|-----------|-------:|-------:|
| Plants | `plants` | +1 | +2 |
| Animals | `animals` | +2 | +3 |
| Metals | `metals` | +3 | -1 |
| Fossil Fuel | `fossilfuel` | +4 | -2 |
| Luxury | `luxury` | +4 | 0 |
| Pollution | `pollution` | -2 | -3 |

As much as possible, these rules should not be too entrenched in the code, and it should be easy to change them during the development of the hypothetical game.

#### Opening File

The application begins by asking the user for the file describing the map. These files must have the extension `map4x`. For example, `mapa1.map4x`, `mapa2.map4x`, or `world.map4x` are valid names for files that describe maps. The "Map File Format" section contains more details about the internal format of these files.

To simplify, the application only looks for maps in the folder `map4xfiles` (all lowercase), located on the current user's _Desktop_/workspace. The application presents the user with a scrollable list of the existing `map4x` files in that folder, and the user selects one of them.

Those who wish to develop a more advanced application, with a bonus in the grade, might try using an asset like [UnitySimpleFileBrowser] that can open `map4x` files anywhere on the disk.

#### Displaying the Map on Screen

After opening a valid file, the application displays the map on the screen. The map must fit on the screen, whatever its actual size. In other words, the map must be scaled to be fully visible on the screen, whether its size is 10x5 or 200x400. Alternatively, you can implement a scroll and/or zoom system, but this is a more advanced and entirely optional approach.

Rendering each _tile_ can be done with the basic sprites provided by Unity. Each type of terrain should be represented by a square sprite whose color should be appropriate to the terrain in question. On top of the terrain sprite, the sprites of the resources present in that _tile_ should be placed. I suggest using circle or triangle sprites, each representing a different resource (use colors/shapes to differentiate between resources). Even if the _tile_ has all possible resources, the background sprite that represents the base terrain type should always be visible.

If you have time, you can improve the presentation and use more appealing graphic tilesets, although this is not highly valued in the final grade, as the main component to be evaluated here is programming. In any case, it should always be possible to distinguish the base terrain and any resources present on it.

If the user clicks on a _tile_, detailed information about it should be presented, as described in the next section.

#### Viewing Detailed Information About a _Tile_

When clicking on a _tile_, an information panel with detailed information about that same _tile_ should be shown. In particular, it should display:

* The rendering of the _tile_ in a slightly larger size.
* What the base terrain is.
* What the resources are.
* How much _gold_ is produced each turn considering the base terrain and existing resources.
* How much _food_ is produced each turn considering the base terrain and existing resources.

The panel can be closed by the user, with the application returning to display the map.

#### Future Functionality

The application's UI should have 5 buttons, clearly marked from 1 to 5. When clicking on one of these buttons, a nearly empty panel should appear, with only the message "For the future 1" for button 1, "For the future 2" for button 2, etc.

The panel can be closed by the user, with the application returning to display the map.

This functionality will be individually implemented during the individual live coding evaluation session. For this reason, it will be very difficult to complete the live coding if you have not successfully completed this project.

#### Others

* It may be useful to have a legend relating the sprites to the types of terrain and different resources they represent.
* The application should not crash with exceptions, but elegantly show the user possible errors that may occur (for example, when reading the file if it has an invalid format).

### Map File Format

The format of the files is as follows (`<component>` means a mandatory component and `[component]` represents an optional component):

```text
<rows> <cols>
<base_terrain> [resource1] [resource2] [...]
<base_terrain> [resource1] [resource2] [...]
<base_terrain> [resource1] [resource2] [...]
<...>
```

The first line indicates the number of rows and columns of the map. The following lines represent _tiles_, starting with the base terrain, followed by the respective optional resources (zero or more). The number of _tiles_ must equal `rows` _x_ `cols`. Each new line (_tile_) in the file advances one column on the map, moving to the next row on the map when it reaches the maximum number of columns. The following map is valid (note that `#` means the beginning of a comment, which should be ignored):

```text
3 4 # Map with 3 rows and 4 columns
grassland # Row 1, column 1
grassland animals # Row 1, column 2
grassland # Row 1, column 3
grassland # Row 1, column 4
# Here start the tiles of the 2nd row
grassland plants # Row 2, column 1
hills metals luxury # etc...
hills luxury
mountain
# Then the tiles on the 3rd and last row
grassland plants animals
hills metals fossilfuel
mountain metals plants fossilfuel
mountain plants
# Everything after # should be ignored
```

This assignment includes a generator of totally random maps for testing your project. The generator is run as follows in the assignment folder (it doesn't work if you are in a folder other than the assignment's):

```text
$ dotnet run --project Generator -- 10 10 mymap.map4x
```

The previous command creates a 10x10 map and saves it in the file `mymap.map4x`.

## Tips and Suggestions

### Project Organization and Class Structure

The project must be properly organized, following by making use of classes, `structs`, and/or enumerations, as appropriate. Each type (i.e., class, `struct`, or enumeration) should be placed in a file with the same name. For example, a class named `Tile` should be placed in the file `Tile.cs`.

In turn, the choice of the collection or collections to use should also be appropriate for the problem.

The class structure should be well thought out and logically organized, making use of *design patterns* as appropriate. In particular, the project should follow an [MVC] approach, and be developed taking into account the principles of object-oriented programming, among others, the [SOLID] principles.

These principles must be balanced with the [KISS] principle, crucial in the development of any application.

## Objectives and Evaluation Criteria

This project has the following objectives:

* **O1** - The program must work as specified.
* **O2** - The project and code should be well organized, specifically:
  * A well-thought-out class structure (see the section "Project Organization and Class Structure").
  * No "dead" code, such as unused variables, properties, or methods.
  * The project compiles and runs without errors and/or *warnings*.
* **O3** - The code should be properly indented, commented, and documented. Documentation should be done with [XML documentation comments][XML].
* **O4** - The Git repository should reflect good use of it, with *commits* from all group members and *commit* messages that follow the best practices for the purpose (as indicated [here](https://chris.beams.io/posts/git-commit/), [here](https://gist.github.com/robertpainsi/b632364184e70900af4ab688decf6f53), [here](https://github.com/erlang/otp/wiki/writing-good-commit-messages) and [here](https://stackoverflow.com/questions/2290016/git-commit-messages-50-72-formatting)). Any binary *assets*, such as images, should be integrated into the repository in Git LFS mode (note that this last point is **very important**).
* **O5** - The report in [Markdown] format (file `README.md`), organized as follows:
  * The project title.
  * Authorship:
    * Names of the authors (first and last) and their respective student numbers.
    * Information on who did what in the project. This information is **mandatory** and must reflect the *commits* made in Git.
  * The legend of the _tiles_, i.e., which type of terrain and resources each _sprite_ represents.
  * Solution Architecture:
    * Description of the solution, with a brief explanation of how the program was organized, indication of the _design patterns_ used and why, as well as the considerations regarding the [SOLID] principles.
    * A simple UML class diagram (i.e., without showing the members of the class) describing the class structure (**mandatory**).
  * References, including idea exchanges with colleagues, reused open-source code (e.g., from StackOverflow), and used third-party libraries. They should be as detailed as possible.
  * **Note:** The report should be simple and brief, with enough information to get a good understanding of the work done. Attention to spelling mistakes and correct [Markdown] formatting, as both will be taken into account in the final grade.

## References

* \[1\] Whitaker, R. B. (2016). **The C# Player's Guide** (3rd Edition). Starbound Software.
* \[2\] Albahari, J. (2017). **C# 7.0 in a Nutshell**. O’Reilly Media.
* \[3\] IMDB (2019). **IMDb Datasets**. Retrieved from <https://www.imdb.com/interfaces/>.
* \[4\] Freeman, E., Robson, E., Bates, B., & Sierra, K. (2004). **Head First Design Patterns**. O'Reilly Media.
* \[5\] Dorsey, T. (2017). **Doing Visual Studio and .NET Code Documentation Right**. Visual Studio Magazine. Retrieved from <https://visualstudiomagazine.com/articles/2017/02/21/vs-dotnet-code-documentation-tools-roundup.aspx>.

## Licenses

* This assignment is made available through the [CC BY-NC-SA 4.0] license.
* The example code is made available through the [MIT] license.

## Metadata

- Author: [Nuno Fachada]
- Affiliation: [Lusófona University, COPELABS][ULHT]

[CC BY-NC-SA 4.0]:https://creativecommons.org/licenses/by-nc-sa/4.0/
[MIT]:http://opensource.org/licenses/MIT
[Nuno Fachada]:https://github.com/fakenmc
[ULHT]:https://www.ulusofona.pt/
[Markdown]:https://guides.github.com/features/mastering-markdown/
[SOLID]:https://en.wikipedia.org/wiki/SOLID
[KISS]:https://en.wikipedia.org/wiki/KISS_principle
[XML]:https://docs.microsoft.com/dotnet/csharp/codedoc
[4X]:https://en.wikipedia.org/wiki/4X
[UnitySimpleFileBrowser]:https://github.com/yasirkula/UnitySimpleFileBrowser
[MVC]:https://www.geeksforgeeks.org/mvc-design-pattern/
